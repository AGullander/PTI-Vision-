<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PTI - Vision | MCS Robotics</title>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-dark: #262626;
      --bg-darker: #1f1f1f;
      --bg-blackish: #181818;
      --gray-border: #3a3a3a;
      --gray-soft: #9ca3af;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-dark);
      color: #f5f5ff;
    }

    .page {
      max-width: 1400px;
      margin: 0 auto;
      padding: 16px 24px 32px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--gray-border);
      margin-bottom: 16px;
    }

    .brand-wrapper {
      display:flex;
      align-items:center;
      gap:16px;
    }

    header img.logo {
      height: 140px;
      width: auto;
      display:block;
    }

    .powered-text {
      font-size: 10px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--gray-soft);
    }

    .badge-learning {
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border: 1px solid transparent;
    }
    .badge-learning-off {
      background: var(--bg-darker);
      color: #e5e7eb;
      border-color: var(--gray-border);
    }
    .badge-learning-on {
      background: rgba(239,68,68,0.12);
      color: #fecaca;
      border-color: #f97373;
      box-shadow: 0 0 12px rgba(248,113,113,0.5);
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 1.6fr;
      gap: 16px;
    }
    .card {
      background: var(--bg-dark);
      border-radius: 16px;
      padding: 16px 18px;
      border: 1px solid var(--gray-border);
    }

    /* Viktigt: canvas är transparent nu, så videon syns under */
    video, canvas {
      width: 100%;
      display: block;
    }

    video {
      background: var(--bg-blackish);
    }

    canvas {
      background: transparent;
    }

    .class-editor select,
    .class-editor input {
      padding: 4px 10px;
      background: var(--bg-blackish);
      color: #e5e7eb;
      border-radius: 999px;
      border: 1px solid var(--gray-border);
      font-size: 12px;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 6px 14px;
      font-size: 13px;
      cursor: pointer;
      background: #4b4b4b;
      color: #f9fafb;
    }
    button.secondary {
      background: var(--bg-blackish);
      color: #e5e7eb;
      border: 1px solid var(--gray-border);
    }
    button:hover:not(:disabled) {
      filter: brightness(1.08);
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    table { width: 100%; font-size: 12px; margin-top: 8px; border-collapse: collapse; }
    th, td { padding: 4px 6px; text-align: left; }
    thead { background: var(--bg-blackish); }
    tbody tr:nth-child(odd) { background: rgba(0,0,0,0.20); }
    tbody tr:nth-child(even) { background: rgba(0,0,0,0.30); }
    tbody tr:hover { background: rgba(148,163,184,0.25); cursor: pointer; }

    .status-text {
      margin-left: auto;
      color: var(--gray-soft);
      font-size:12px;
    }

    .summary-title-main {
      font-size: 20px;
      font-weight: 600;
      color: #e5e7eb;
      margin-bottom: 2px;
    }
    .summary-title-sub {
      font-size: 14px;
      font-weight: 500;
      color: var(--gray-soft);
      margin-bottom: 6px;
    }
    .badges-row {
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:4px;
      margin-bottom:6px;
    }
    .badge {
      padding:3px 8px;
      border-radius:999px;
      font-size:11px;
      border:1px solid transparent;
    }
    .badge-status-ok {
      background: rgba(34,197,94,0.15);
      border-color: rgba(34,197,94,0.6);
      color:#bbf7d0;
    }
    .badge-status-alert {
      background: rgba(248,113,113,0.18);
      border-color: rgba(248,113,113,0.8);
      color:#fecaca;
    }
    .badge-stage {
      background: var(--bg-blackish);
      border-color: var(--gray-border);
      color:#e5e7eb;
    }
    .badge-muted {
      background: var(--bg-darker);
      border-color: var(--gray-border);
      color:#e5e7eb;
    }

    .stage-controls {
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      font-size:12px;
      color:var(--gray-soft);
    }
    .stage-label {
      font-size:12px;
      color:#e5e7eb;
    }
    .btn-pill-active {
      background:#555555;
      color:#f9fafb;
    }

    .wash-container {
      margin-top:12px;
      font-size:12px;
    }
    .wash-boxes {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:6px;
    }
    .wash-box {
      flex:1 1 160px;
      min-width:160px;
      background: var(--bg-blackish);
      border-radius:10px;
      border:1px solid var(--gray-border);
      padding:8px 10px;
    }
    .wash-box h4 {
      font-size:12px;
      margin-bottom:4px;
      color:#e5e7eb;
    }
    .wash-box ul {
      margin-top:2px;
      padding-left:16px;
      max-height:140px;
      overflow:auto;
    }
    .wash-box li {
      margin-bottom:2px;
    }

    .wash-item {
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:3px;
    }
    .severity-dot {
      width:8px;
      height:8px;
      border-radius:999px;
      flex-shrink:0;
    }
    .severity-high   { background:#ef4444; }
    .severity-medium { background:#eab308; }
    .severity-low    { background:#6b7280; }

    .wash-category-label {
      font-size:11px;
      font-weight:600;
      margin-top:4px;
      margin-bottom:2px;
      color:var(--gray-soft);
    }
    .wash-item-text-main {
      font-size:11px;
    }
    .wash-item-text-sub {
      font-size:10px;
      color:var(--gray-soft);
    }

    .legend-row {
      margin-top:6px;
      font-size:10px;
      color:var(--gray-soft);
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    .legend-item {
      display:flex;
      align-items:center;
      gap:4px;
    }
    .legend-color-box {
      width:10px;
      height:10px;
      border-radius:3px;
    }

    .cont-scale-wrapper {
      margin-top:10px;
      padding:10px 12px;
      border-radius:10px;
      background: var(--bg-blackish);
      border:1px solid var(--gray-border);
    }
    .cont-scale-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:6px;
      font-size:11px;
      color:#e5e7eb;
    }
    .cont-scale-bar {
      display:flex;
      gap:6px;
      align-items:center;
    }
    .cont-box {
      width:26px;
      height:16px;
      border-radius:4px;
      background: var(--bg-dark);
      border:1px solid var(--gray-border);
      transition:background 0.2s, transform 0.2s, border-color 0.2s;
    }
    .cont-box.active {
      transform:translateY(-1px);
    }
    .cont-scale-label {
      font-size:10px;
      color:var(--gray-soft);
      margin-top:4px;
      text-align:right;
    }

    /* Nya små kontroller-rutor */
    .analysis-controls {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 12px;
      color: var(--gray-soft);
      align-items: center;
    }
    .analysis-controls select {
      padding: 4px 10px;
      background: var(--bg-blackish);
      color: #e5e7eb;
      border-radius: 999px;
      border: 1px solid var(--gray-border);
      font-size: 12px;
    }
    .analysis-controls label {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .analysis-controls input[type="checkbox"] {
      accent-color: #22c55e;
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <div class="brand-wrapper">
        <img src="/static/pti-logo.png" class="logo" alt="PTI – Pre Trip Inspection" />
        <div class="powered-text">Powered by MCS Robotics</div>
      </div>

      <span id="learningBadge" class="badge-learning badge-learning-off">
        LEARNING MODE OFF
      </span>
    </header>

    <div class="layout">
      <!-- Left: video & controls -->
      <section class="card">
        <h2 style="color:#e5e7eb;margin-bottom:10px;font-size:16px;">VIDEO & ANALYSIS</h2>

        <div style="position:relative;">
          <video id="video" controls muted></video>
          <canvas id="overlay" style="position:absolute;inset:0;pointer-events:none;"></canvas>
        </div>

        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
          <input type="file" id="fileInput" accept="video/*" style="display:none" />
          <button id="btnChoose" class="secondary">Choose video</button>
          <input type="file" id="imageInput" accept="image/*" style="display:none" />
          <button id="btnChooseImage" class="secondary">Choose image (test)</button>

          <button id="btnPlay">Play</button>
          <button id="btnPause">Pause</button>
          <button id="btnAnalyze" disabled>Analyze paused frame</button>
          <button id="btnAuto" class="secondary">Auto: off</button>
          <button id="btnLearn" class="secondary">Learning: off</button>

          <span class="status-text">
            Backend:
            <span id="backendStatus">not tested</span>
          </span>
        </div>

        <!-- Nya kontroller för damage_sensitivity, spot_mode, vision-backend & GPT -->
        <div class="analysis-controls">
          <div>
            <span>Damage sensitivity:</span>
            <select id="damageSensitivity">
              <option value="low">low</option>
              <option value="medium" selected>medium</option>
              <option value="high">high</option>
            </select>
          </div>
          <div>
            <span>Dark spots:</span>
            <select id="spotMode">
              <option value="auto" selected>auto</option>
              <option value="mold_only">mold_only</option>
              <option value="off">off</option>
            </select>
          </div>
          <div>
            <span>Vision backend:</span>
            <select id="visionBackend">
              <option value="auto" selected>auto</option>
              <option value="none">none</option>
              <option value="openvino">openvino</option>
              <option value="openai">openai</option>
              <option value="llava">llava</option>
            </select>
          </div>
          <label>
            <input type="checkbox" id="useVisionGpt" checked />
            use_vision_gpt
          </label>
          <label>
            <input type="checkbox" id="useTextGpt" checked />
            use_text_gpt
          </label>
        </div>

        <div class="stage-controls">
          <span>Inspection stage:</span>
          <button id="btnStageNone" class="secondary">None</button>
          <button id="btnStagePre" class="secondary">Pre wash</button>
          <button id="btnStagePost" class="secondary">Post wash</button>
          <span id="stageLabel" class="stage-label">Stage: none</span>
        </div>

        <div class="class-editor" style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <span style="font-size:12px;color:var(--gray-soft);">Label for new/selected box:</span>
          <select id="labelSelect">
            <option value="">– select class –</option>

            <!-- Damage -->
            <option value="DamageDent">DamageDent – dent</option>
            <option value="DamageScratch">DamageScratch – scratch</option>
            <option value="DamageHole">DamageHole – hole</option>

            <!-- Dirt / loose objects / discoloration -->
            <option value="Dirt">Dirt – dirt</option>
            <option value="LooseObject">LooseObject – loose object</option>
            <option value="Discoloration">Discoloration – discoloration</option>

            <!-- Other -->
            <option value="Person">Person</option>
            <option value="Person in danger zone">Person in danger zone</option>
            <option value="Vehicle">Vehicle</option>
            <option value="Blocked door">Blocked door</option>

            <!-- Custom label -->
            <option value="__custom__">Custom label…</option>
          </select>

          <input type="text" id="customLabel" placeholder="Custom label (if selected)" />
          <button id="btnApplyLabel" class="secondary">Update selected box</button>
        </div>

        <p style="margin-top:8px;font-size:11px;color:var(--gray-soft);">
          Draw boxes directly on the image to create new objects. In <strong>Learning mode ON</strong>,
          these objects are saved as training data (YOLO + visual memory).
        </p>
      </section>

      <!-- Right: status & objects -->
      <section class="card">
        <h2 style="color:#e5e7eb;margin-bottom:10px;font-size:16px;">OBJECTS & STATUS</h2>

        <div id="containerSummary" style="margin-bottom:10px;">
          <div id="summaryContainerId" class="summary-title-main">Container ID: –</div>
          <div id="summaryContainerType" class="summary-title-sub">Type: –</div>

          <div class="badges-row">
            <span id="summaryStatusBadge" class="badge badge-muted">Status: unknown</span>
            <span id="summaryStageBadge" class="badge badge-stage">Stage: –</span>
            <span id="summaryPeopleBadge" class="badge badge-muted">Person nearby: –</span>
            <span id="summaryDoorBadge" class="badge badge-muted">Doors: –</span>
            <span id="summaryAnomBadge" class="badge badge-muted">Anomalies: –</span>
          </div>
        </div>

        <div class="cont-scale-wrapper">
          <div class="cont-scale-header">
            <span>Contamination level</span>
            <span id="contScaleValueText">– / 9</span>
          </div>
          <div class="cont-scale-bar" id="contScaleBar">
            <div class="cont-box" data-level="1"></div>
            <div class="cont-box" data-level="2"></div>
            <div class="cont-box" data-level="3"></div>
            <div class="cont-box" data-level="4"></div>
            <div class="cont-box" data-level="5"></div>
            <div class="cont-box" data-level="6"></div>
            <div class="cont-box" data-level="7"></div>
            <div class="cont-box" data-level="8"></div>
            <div class="cont-box" data-level="9"></div>
          </div>
          <div class="cont-scale-label">
            Uses all findings to estimate cleaning intensity (water, chemicals, time).
          </div>
        </div>

        <div id="washResults" class="wash-container">
          <h3 style="font-size:13px;color:var(--gray-soft);">PreWash & Resolved</h3>
          <div style="font-size:11px;color:var(--gray-soft);margin-top:2px;">
            Mark one frame as <strong>Pre wash</strong> and another as <strong>Post wash</strong>
            for the same container. The system shows PreWash Remarks and which of them are Resolved.
          </div>

          <div class="legend-row">
            <div class="legend-item">
              <div class="legend-color-box" style="background:#ef4444;"></div>
              <span>Damage (high severity)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color-box" style="background:#eab308;"></div>
              <span>Dirt / loose object / discoloration (medium)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color-box" style="background:#6b7280;"></div>
              <span>Other (low)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color-box" style="background:#a855f7;"></div>
              <span>Dark spots (mold / black stains)</span>
            </div>
          </div>

          <div class="wash-boxes">
            <div class="wash-box">
              <h4>PreWash Remarks</h4>
              <div style="font-size:11px;color:var(--gray-soft);" id="prewashInfo">No PreWash inspection yet.</div>
              <ul id="prewashList"></ul>
            </div>

            <div class="wash-box">
              <h4>Resolved</h4>
              <div style="font-size:11px;color:var(--gray-soft);" id="resolvedInfo">Nothing resolved yet.</div>
              <ul id="resolvedList"></ul>
            </div>
          </div>
        </div>

        <table style="margin-top:12px;">
          <thead>
            <tr>
              <th>#</th>
              <th>Display name</th>
              <th>Label</th>
              <th>Category</th>
              <th>Conf.</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="detectionsBody"></tbody>
        </table>

        <p style="margin-top:8px;font-size:11px;color:var(--gray-soft);">
          Number (#) matches the box in the video. Click a row to highlight the box.
          ✕ trains the object as <code>__IGNORE__</code> (if learning mode is on).
        </p>
      </section>
    </div>
  </div>

  <script>
  window.addEventListener('DOMContentLoaded', () => {
    const API_BASE = "http://localhost:8000";

    // DOM refs
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    const fileInput = document.getElementById('fileInput');
    const imageInput = document.getElementById('imageInput');
    const btnChoose = document.getElementById('btnChoose');
    const btnChooseImage = document.getElementById('btnChooseImage');
    const btnPlay = document.getElementById('btnPlay');
    const btnPause = document.getElementById('btnPause');
    const btnAnalyze = document.getElementById('btnAnalyze');
    const btnAuto = document.getElementById('btnAuto');
    const btnLearn = document.getElementById('btnLearn');
    const learningBadge = document.getElementById('learningBadge');
    const backendStatus = document.getElementById('backendStatus');

    const labelSelect = document.getElementById('labelSelect');
    const customLabel = document.getElementById('customLabel');
    const btnApplyLabel = document.getElementById('btnApplyLabel');
    const detectionsBody = document.getElementById('detectionsBody');

    const btnStageNone = document.getElementById('btnStageNone');
    const btnStagePre = document.getElementById('btnStagePre');
    const btnStagePost = document.getElementById('btnStagePost');
    const stageLabel = document.getElementById('stageLabel');

    const summaryContainerId = document.getElementById('summaryContainerId');
    const summaryContainerType = document.getElementById('summaryContainerType');
    const summaryStatusBadge = document.getElementById('summaryStatusBadge');
    const summaryStageBadge = document.getElementById('summaryStageBadge');
    const summaryPeopleBadge = document.getElementById('summaryPeopleBadge');
    const summaryDoorBadge = document.getElementById('summaryDoorBadge');
    const summaryAnomBadge = document.getElementById('summaryAnomBadge');

    const prewashInfo = document.getElementById('prewashInfo');
    const prewashList = document.getElementById('prewashList');
    const resolvedInfo = document.getElementById('resolvedInfo');
    const resolvedList = document.getElementById('resolvedList');

    const contScaleBar = document.getElementById('contScaleBar');
    const contScaleValueText = document.getElementById('contScaleValueText');

    // Nya kontroller (matchar backend-parametrar)
    const damageSensitivitySelect = document.getElementById('damageSensitivity');
    const spotModeSelect = document.getElementById('spotMode');
    const visionBackendSelect = document.getElementById('visionBackend');
    const useVisionGptCheckbox = document.getElementById('useVisionGpt');
    const useTextGptCheckbox = document.getElementById('useTextGpt');

    // State
    let lastDetections = [];
    let autoAnalyze = false;
    let autoTimer = null;
    let analyzing = false;
    let selectedIndex = -1;
    let learningMode = false;
    let currentStage = null; // "pre" | "post" | null

    // --- Helpers ---
    function setLearningMode(on) {
      learningMode = on;
      
      // Enable/disable canvas pointer events for drawing
      if (canvas) {
        canvas.style.pointerEvents = on ? "auto" : "none";
        canvas.style.cursor = on ? "crosshair" : "default";
      }
      
      if (on) {
        btnLearn.textContent = "Learning: on";
        btnLearn.classList.remove("secondary");
        learningBadge.textContent = "LEARNING MODE ON";
        learningBadge.classList.add("badge-learning-on");
        learningBadge.classList.remove("badge-learning-off");
      } else {
        btnLearn.textContent = "Learning: off";
        btnLearn.classList.add("secondary");
        learningBadge.textContent = "LEARNING MODE OFF";
        learningBadge.classList.remove("badge-learning-on");
        learningBadge.classList.add("badge-learning-off");
      }
    }

    function updateBackendStatus(text, ok = false) {
      backendStatus.textContent = text;
      backendStatus.style.color = ok ? "#22c55e" : "#f97373";
    }

    function colorForCategory(cat, label) {
      const c = (cat || "").toLowerCase();
      const l = (label || "").toLowerCase();

      // special: dark spots / mold
      if (l.includes("dark spot") || l.includes("mold") || l.includes("mould") || l.includes("mögel")) {
        return "#a855f7"; // lila
      }

      if (c === "damage" || l.startsWith("damage")) return "#ef4444";
      if (
        l.includes("dirt") || l.includes("smuts") ||
        l.includes("looseobject") || l.includes("loose object") ||
        l.includes("löst föremål") ||
        l.includes("discoloration") || l.includes("missfärgning")
      ) return "#eab308";
      if (c === "lock") return "#22c55e";
      if (c === "door" || c === "door_open" || c === "door_closed") return "#e5e7eb";
      if (c === "human") return "#f9fafb";
      return "#d1d5db";
    }

    function setStage(stage) {
      currentStage = stage;

      btnStageNone.classList.remove('btn-pill-active');
      btnStagePre.classList.remove('btn-pill-active');
      btnStagePost.classList.remove('btn-pill-active');

      if (stage === 'pre') {
        btnStagePre.classList.add('btn-pill-active');
        stageLabel.textContent = "Stage: Pre wash";
      } else if (stage === 'post') {
        btnStagePost.classList.add('btn-pill-active');
        stageLabel.textContent = "Stage: Post wash";
      } else {
        btnStageNone.classList.add('btn-pill-active');
        stageLabel.textContent = "Stage: none";
      }
    }

    // Färgskala 1–9: grön (1) -> röd (9)
    function levelColor(level) {
      // 1 => 120 (grön), 9 => 0 (röd)
      const hue = (9 - level) / 8 * 120;
      return `hsl(${hue}, 80%, 55%)`;
    }

    function updateContaminationScale(level) {
      const n = Math.min(9, Math.max(1, level || 1));
      const boxes = contScaleBar.querySelectorAll(".cont-box");
      boxes.forEach((box) => {
        const lv = parseInt(box.getAttribute("data-level"), 10);
        if (lv <= n) {
          box.classList.add("active");
          const col = levelColor(lv);
          box.style.background = col;
          box.style.borderColor = col;
        } else {
          box.classList.remove("active");
          box.style.background = "var(--bg-dark)";
          box.style.borderColor = "var(--gray-border)";
        }
      });
      contScaleValueText.textContent = n + " / 9";
    }

    function classifyDiffItem(item) {
      const cat = (item.category || "").toLowerCase();
      const label = (item.label || "").toLowerCase();
      let group = "other";
      let severity = "low";

      if (cat === "damage" || label.startsWith("damage")) {
        group = "damage";
        severity = "high";
      } else if (
        label.includes("dirt") ||
        label.includes("smuts") ||
        label.includes("loose object") ||
        label.includes("looseobject") ||
        label.includes("löst föremål") ||
        label.includes("discoloration") ||
        label.includes("missfärgning") ||
        label.includes("dark spot") ||
        label.includes("mold") ||
        label.includes("mould")
      ) {
        group = "dirt";
        severity = "medium";
      }
      return { group, severity };
    }

    function severityLabel(sev) {
      if (sev === "high") return "High (damage)";
      if (sev === "medium") return "Medium (dirt/object)";
      return "Low";
    }

    function buildPrewashResolvedList(listEl, infoEl, items, emptyText) {
      listEl.innerHTML = "";
      if (!items || items.length === 0) {
        infoEl.textContent = emptyText;
        return;
      }
      infoEl.textContent = "";

      const damageItems = [];
      const dirtItems = [];
      const otherItems = [];

      items.forEach((item) => {
        const { group, severity } = classifyDiffItem(item);
        if (group === "damage") damageItems.push({ item, severity });
        else if (group === "dirt") dirtItems.push({ item, severity });
        else otherItems.push({ item, severity });
      });

      function renderGroup(label, bucket) {
        if (!bucket.length) return;
        const header = document.createElement("div");
        header.className = "wash-category-label";
        header.textContent = label;
        listEl.appendChild(header);

        bucket.forEach(({ item, severity }) => {
          const li = document.createElement("li");
          const row = document.createElement("div");
          row.className = "wash-item";

          const dot = document.createElement("div");
          dot.className = "severity-dot " +
            (severity === "high" ? "severity-high" :
             severity === "medium" ? "severity-medium" :
             "severity-low");

          const textBox = document.createElement("div");
          const main = document.createElement("div");
          main.className = "wash-item-text-main";
          main.textContent = item.label || "Unknown";

          const sub = document.createElement("div");
          sub.className = "wash-item-text-sub";
          const catText = item.category ? "Category: " + item.category : "";
          const sevText = "Severity: " + severityLabel(severity);
          sub.textContent = catText ? (catText + " | " + sevText) : sevText;

          textBox.appendChild(main);
          textBox.appendChild(sub);

          row.appendChild(dot);
          row.appendChild(textBox);
          li.appendChild(row);
          listEl.appendChild(li);
        });
      }

      renderGroup("Damage", damageItems);
      renderGroup("Dirt / loose objects / discoloration", dirtItems);
      renderGroup("Other", otherItems);
    }

    function updatePrewashResolved(prewashItems, resolvedItems) {
      buildPrewashResolvedList(prewashList, prewashInfo, prewashItems, "No PreWash inspection yet.");
      buildPrewashResolvedList(resolvedList, resolvedInfo, resolvedItems, "Nothing resolved yet.");
    }

    function updateSummaryFromResponse(data) {
      summaryContainerId.textContent = "Container ID: " + (data.container_id || "UNKNOWN");
      summaryContainerType.textContent = "Type: " + (data.container_type || "Unknown type");

      summaryStatusBadge.className = "badge";
      if (data.status === "alert") {
        summaryStatusBadge.classList.add("badge-status-alert");
        summaryStatusBadge.textContent = "Status: ALERT";
      } else {
        summaryStatusBadge.classList.add("badge-status-ok");
        summaryStatusBadge.textContent = "Status: OK";
      }

      summaryStageBadge.className = "badge badge-stage";
      let stageText = "–";
      if (data.inspection_stage === "pre") stageText = "Pre wash";
      if (data.inspection_stage === "post") stageText = "Post wash";
      summaryStageBadge.textContent = "Stage: " + stageText;

      summaryPeopleBadge.className = "badge badge-muted";
      summaryPeopleBadge.textContent = data.people_nearby
        ? "Person nearby: Yes"
        : "Person nearby: No";

      summaryDoorBadge.className = "badge badge-muted";
      if (data.door_status === "open") {
        summaryDoorBadge.textContent = "Doors: Open";
      } else if (data.door_status === "closed") {
        summaryDoorBadge.textContent = "Doors: Closed";
      } else {
        summaryDoorBadge.textContent = "Doors: Unknown";
      }

      summaryAnomBadge.className = "badge badge-muted";
      summaryAnomBadge.textContent = data.anomalies_present
        ? "Anomalies: Yes"
        : "Anomalies: No";

      updateContaminationScale(data.contamination_index || 1);
      updatePrewashResolved(data.prewash_remarks || [], data.resolved_remarks || []);
    }

    function drawDetections(detList) {
      if (!video.videoWidth) return;

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;

      detList.forEach((det, idx) => {
        if (!det.bbox) return;
        const box = det.bbox;
        const color = colorForCategory(det.category, det.label);

        ctx.strokeStyle = color;
        ctx.strokeRect(box.x, box.y, box.w, box.h);

        const text = "#" + (idx + 1) + " " + (det.legend || det.label || "");
        ctx.font = "12px -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        const tw = ctx.measureText(text).width + 6;
        const th = 16;

        let tx = box.x;
        let ty = box.y - th - 2;
        if (ty < 0) ty = box.y + box.h + 2;
        if (tx + tw > canvas.width) tx = canvas.width - tw - 2;

        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fillRect(tx, ty, tw, th);
        ctx.fillStyle = "#f9fafb";
        ctx.fillText(text, tx + 3, ty + th - 4);
      });
    }

    function updateTable(detList) {
      detectionsBody.innerHTML = "";

      detList.forEach((det, idx) => {
        const tr = document.createElement("tr");

        const confText = det.confidence != null
          ? (det.confidence * 100).toFixed(1) + "%"
          : "-";

        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td>${det.legend || det.label || ""}</td>
          <td>${det.label || ""}</td>
          <td>${det.category || ""}</td>
          <td>${confText}</td>
          <td><button data-del="${idx}" style="color:#f87171;background:none;border:none;cursor:pointer;">✕</button></td>
        `;

        tr.addEventListener("click", () => {
          selectedIndex = idx;
          drawDetections(detList);
        });

        const btnDel = tr.querySelector("button[data-del]");
        btnDel.addEventListener("click", (ev) => {
          ev.stopPropagation();
          ignoreDetection(idx);
        });

        detectionsBody.appendChild(tr);
      });
    }

    function getSelectedLabel() {
      const val = labelSelect.value;
      if (!val) return null;
      if (val === "__custom__") {
        const t = customLabel.value.trim();
        return t || null;
      }
      return val;
    }

    function trainRect(det, label) {
      if (!learningMode) return;
      if (!det || !det.bbox || !video.videoWidth) return;
      const box = det.bbox;

      // Visual memory (patch)
      const patchCanvas = document.createElement("canvas");
      patchCanvas.width = box.w;
      patchCanvas.height = box.h;
      const pctx = patchCanvas.getContext("2d");
      pctx.drawImage(video, box.x, box.y, box.w, box.h, 0, 0, box.w, box.h);

      patchCanvas.toBlob((blob) => {
        if (!blob) return;
        const fd = new FormData();
        fd.append("label", label);
        fd.append("image", blob, "patch.jpg");
        fetch(API_BASE + "/api/train_visual", {
          method: "POST",
          headers: {
            "X-API-Key": "pti_demo_key_2025"
          },
          body: fd
        }).catch(console.error);
      }, "image/jpeg", 0.9);

      // YOLO-träning (full frame + bbox)
      const fullCanvas = document.createElement("canvas");
      fullCanvas.width = video.videoWidth;
      fullCanvas.height = video.videoHeight;
      fullCanvas.getContext("2d").drawImage(video, 0, 0);

      fullCanvas.toBlob((blob) => {
        if (!blob) return;
        const fd = new FormData();
        fd.append("label", label);
        fd.append("x", String(Math.round(box.x)));
        fd.append("y", String(Math.round(box.y)));
        fd.append("w", String(Math.round(box.w)));
        fd.append("h", String(Math.round(box.h)));
        fd.append("image", blob, "frame.jpg");
        fetch(API_BASE + "/api/log_yolo_sample", {
          method: "POST",
          headers: {
            "X-API-Key": "pti_demo_key_2025"
          },
          body: fd
        }).catch(console.error);
      }, "image/jpeg", 0.9);
    }

    function ignoreDetection(index) {
      if (!lastDetections[index]) return;
      const det = lastDetections[index];
      trainRect(det, "__IGNORE__");
      lastDetections.splice(index, 1);
      drawDetections(lastDetections);
      updateTable(lastDetections);
    }

    async function analyzeCurrentFrame() {
      if (analyzing) {
        console.log('Already analyzing, skipping...');
        return;
      }
      if (!video.videoWidth || video.readyState < 2) {
        console.log('Video not ready:', { videoWidth: video.videoWidth, readyState: video.readyState });
        return;
      }

      console.log('Starting frame analysis...');
      analyzing = true;
      btnAnalyze.disabled = true;
      updateBackendStatus("analyzing...", true);

      try {
        const snapCanvas = document.createElement("canvas");
        snapCanvas.width = video.videoWidth;
        snapCanvas.height = video.videoHeight;
        const sctx = snapCanvas.getContext("2d");
        sctx.drawImage(video, 0, 0);

        const blob = await new Promise((resolve) => {
          snapCanvas.toBlob(resolve, "image/jpeg", 0.9);
        });
        if (!blob) throw new Error("Failed to create image blob");

        console.log('Frame captured, blob size:', blob.size);

        const fd = new FormData();
        fd.append("image", blob, "frame.jpg");

        // Hämta värden från UI, anpassat till backend-signaturen
        const damageSensitivity = damageSensitivitySelect.value;
        const spotMode = spotModeSelect.value;
        const visionBackend = visionBackendSelect.value;
        const useVision = useVisionGptCheckbox.checked;
        const useText = useTextGptCheckbox.checked;

        let url = `${API_BASE}/api/analyze?damage_sensitivity=${encodeURIComponent(damageSensitivity)}&spot_mode=${encodeURIComponent(spotMode)}&vision_backend=${encodeURIComponent(visionBackend)}&use_vision_gpt=${useVision}&use_text_gpt=${useText}`;

        if (currentStage === "pre" || currentStage === "post") {
          url += `&inspection_stage=${encodeURIComponent(currentStage)}`;
        }

        console.log('Sending to:', url);

        const resp = await fetch(url, {
          method: "POST",
          headers: {
            "X-API-Key": "pti_demo_key_2025"
          },
          body: fd
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error('Backend error:', resp.status, txt);
          updateBackendStatus("error " + resp.status, false);
          throw new Error("Backend error: " + txt);
        }

        const data = await resp.json();
        console.log('Analysis complete, detections:', data.detections?.length || 0);
        console.log('Full response:', data);
        
        lastDetections = data.detections || [];
        drawDetections(lastDetections);
        updateTable(lastDetections);
        updateSummaryFromResponse(data);
        updateBackendStatus("ok", true);
      } catch (err) {
        console.error('Analysis error:', err);
        updateBackendStatus("error", false);
      } finally {
        analyzing = false;
        btnAnalyze.disabled = false;
      }
    }

    function startAutoAnalyze() {
      if (autoTimer) return;
      autoTimer = setInterval(() => {
        if (!video.paused && !video.ended) {
          analyzeCurrentFrame();
        }
      }, 2000);
    }

    function stopAutoAnalyze() {
      if (autoTimer) {
        clearInterval(autoTimer);
        autoTimer = null;
      }
    }

    // --- Mouse drawing for new boxes (simplified) ---
    let isDrawing = false;
    let drawStart = null;
    let drawRect = null;

    canvas.addEventListener("mousedown", (e) => {
      if (!learningMode) return;
      if (!video.videoWidth) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      isDrawing = true;
      drawStart = { x, y };
      drawRect = { x, y, w: 0, h: 0 };
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!isDrawing || !drawStart) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      drawRect.w = x - drawStart.x;
      drawRect.h = y - drawStart.y;

      const tmp = [...lastDetections];
      const w = Math.abs(drawRect.w);
      const h = Math.abs(drawRect.h);
      const rx = drawRect.w < 0 ? drawStart.x + drawRect.w : drawStart.x;
      const ry = drawRect.h < 0 ? drawStart.y + drawRect.h : drawStart.y;

      tmp.push({
        label: "(new)",
        category: "manual",
        confidence: 1.0,
        bbox: { x: Math.round(rx), y: Math.round(ry), w: Math.round(w), h: Math.round(h) },
        legend: "(new box)"
      });
      drawDetections(tmp);
    });

    canvas.addEventListener("mouseup", () => {
      if (!isDrawing || !drawRect) return;
      isDrawing = false;

      const w = Math.abs(drawRect.w);
      const h = Math.abs(drawRect.h);
      if (w < 10 || h < 10) {
        drawRect = null;
        drawDetections(lastDetections);
        return;
      }
      const rx = drawRect.w < 0 ? drawStart.x + drawRect.w : drawStart.x;
      const ry = drawRect.h < 0 ? drawStart.y + drawRect.h : drawStart.y;

      const label = getSelectedLabel() || "CustomObject";
      const det = {
        label,
        category: "manual",
        confidence: 1.0,
        bbox: { x: Math.round(rx), y: Math.round(ry), w: Math.round(w), h: Math.round(h) },
        legend: label
      };
      lastDetections.push(det);
      drawDetections(lastDetections);
      updateTable(lastDetections);

      trainRect(det, label);
      drawRect = null;
      drawStart = null;
    });

    // --- Events ---
    if (btnChoose && fileInput) {
      btnChoose.addEventListener('click', () => {
        console.log('Choose video button clicked');
        fileInput.click();
      });
    } else {
      console.error('btnChoose or fileInput not found!', { btnChoose, fileInput });
    }

    if (btnChooseImage && imageInput) {
      btnChooseImage.addEventListener('click', () => {
        console.log('Choose image button clicked');
        imageInput.click();
      });
    } else {
      console.error('btnChooseImage or imageInput not found!', { btnChooseImage, imageInput });
    }

    fileInput.addEventListener('change', () => {
      console.log('Video file selected');
      const file = fileInput.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      video.src = url;
      video.load();
      btnAnalyze.disabled = false;

      const p = video.play();
      if (p && p.catch) {
        p.catch(() => {
          // Ignorera autoplay-fel
        });
      }
    });

    imageInput.addEventListener('change', async () => {
      console.log('Image file selected');
      const file = imageInput.files[0];
      if (!file) return;
      
      // Load image into video element for display
      const url = URL.createObjectURL(file);
      video.poster = url;
      video.src = "";
      
      // Immediately analyze the image
      updateBackendStatus("analyzing image...", true);
      
      try {
        const fd = new FormData();
        fd.append("image", file);

        const damageSensitivity = damageSensitivitySelect.value;
        const spotMode = spotModeSelect.value;
        const visionBackend = visionBackendSelect.value;
        const useVision = useVisionGptCheckbox.checked;
        const useText = useTextGptCheckbox.checked;

        let apiUrl = `${API_BASE}/api/analyze?damage_sensitivity=${encodeURIComponent(damageSensitivity)}&spot_mode=${encodeURIComponent(spotMode)}&vision_backend=${encodeURIComponent(visionBackend)}&use_vision_gpt=${useVision}&use_text_gpt=${useText}`;

        if (currentStage === "pre" || currentStage === "post") {
          apiUrl += `&inspection_stage=${encodeURIComponent(currentStage)}`;
        }

        console.log('Sending image to:', apiUrl);

        const resp = await fetch(apiUrl, {
          method: "POST",
          headers: {
            "X-API-Key": "pti_demo_key_2025"
          },
          body: fd
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error('API error:', resp.status, txt);
          updateBackendStatus("error " + resp.status, false);
          alert("Backend error: " + txt);
          return;
        }

        const data = await resp.json();
        console.log('Analysis result:', data);
        
        lastDetections = data.detections || [];
        
        // Load the image to get dimensions for drawing
        const img = new Image();
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          video.style.aspectRatio = `${img.width} / ${img.height}`;
          
          // Draw the image on canvas background (since video is empty)
          ctx.drawImage(img, 0, 0);
          
          // Draw detections on top
          drawDetections(lastDetections);
          updateTable(lastDetections);
          updateSummaryFromResponse(data);
          updateBackendStatus("ok", true);
        };
        img.src = url;

      } catch (err) {
        console.error('Image analysis error:', err);
        updateBackendStatus("error", false);
        alert("Error analyzing image: " + err.message);
      }
    });

    video.addEventListener("loadedmetadata", () => {
      console.log('Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    });

    video.addEventListener("error", () => {
      console.error("Video error:", video.error);
      updateBackendStatus("video error", false);
    });

    btnPlay.addEventListener('click', () => video.play());
    btnPause.addEventListener('click', () => video.pause());
    btnAnalyze.addEventListener('click', analyzeCurrentFrame);

    btnAuto.addEventListener('click', () => {
      autoAnalyze = !autoAnalyze;
      if (autoAnalyze) {
        btnAuto.textContent = "Auto: on";
        btnAuto.classList.remove("secondary");
        startAutoAnalyze();
      } else {
        btnAuto.textContent = "Auto: off";
        btnAuto.classList.add("secondary");
        stopAutoAnalyze();
      }
    });

    btnLearn.addEventListener('click', () => setLearningMode(!learningMode));

    btnStageNone.addEventListener('click', () => setStage(null));
    btnStagePre.addEventListener('click', () => setStage('pre'));
    btnStagePost.addEventListener('click', () => setStage('post'));

    btnApplyLabel.addEventListener('click', () => {
      if (selectedIndex < 0 || !lastDetections[selectedIndex]) return;
      const newLabel = getSelectedLabel();
      if (!newLabel) return;
      lastDetections[selectedIndex].label = newLabel;
      lastDetections[selectedIndex].legend = newLabel;
      drawDetections(lastDetections);
      updateTable(lastDetections);
      trainRect(lastDetections[selectedIndex], newLabel);
    });

    // Prova backend
    fetch(API_BASE + "/api/analyze", { method: "OPTIONS" })
      .then(() => updateBackendStatus("reachable", true))
      .catch(() => updateBackendStatus("unreachable", false));

    // Initial state
    setLearningMode(false);
    setStage(null);
  });
  </script>
</body>
</html>
